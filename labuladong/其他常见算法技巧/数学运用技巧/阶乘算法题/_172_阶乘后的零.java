package labuladong.其他常见算法技巧.数学运用技巧.阶乘算法题;

// https://leetcode.cn/problems/factorial-trailing-zeroes/
public class _172_阶乘后的零 {
    // 肯定不可能真去把 n! 的结果算出来，阶乘增长可是比指数增长都恐怖，趁早死了这条心吧。
    
    // 那么，结果的末尾的 0 从哪里来的？我们有没有投机取巧的方法计算出来？
    // 首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。
    // 也就是说，问题转化为：n! 最多可以分解出多少个因子 2 和 5？
    // 比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？
    // 这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。
    // 25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。
    // 现在，问题转化为：n! 最多可以分解出多少个因子 5？
    // 难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？

    // 这样，我们假设 n = 125，来算一算 125! 的结果末尾有几个 0：
    // 首先，125 / 5 = 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。
    // 但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，
    // 那么我们再计算出 125! 中有 125 / 25 = 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。
    // 够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，
    // 那么我们还得再计算出 125! 中有 125 / 125 = 1 个 125 的倍数，它还可以额外再提供一个因子 5。

    // 这下应该够了，125! 最多可以分解出 25 + 5 + 1 = 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。
    // 总结一下，这道题的解法就是：我们需要先算 n! 中有多少个因子 5，
    // 然后再算有多少个因子 25，再算有多少个因子 125，以此类推，直到算完所有的因子。
    class Solution1 {
        public int trailingZeroes(int n) {
            int res = 0;
            long divisor = 5;
            while (divisor <= n) {
                res += n / divisor;
                divisor *= 5;
            }
            return res;
        }
    }

    // 上述代码可以改写地更简单一些：
    class Solution2 {
        int trailingZeroes(int n) {
            int res = 0;
            for (int d = n; d / 5 > 0; d = d / 5) {
                res += d / 5;
            }
            return res;
        }
    }
}
