# 非递归算法分析

## 只需把每一层的复杂度相乘就是总的时间复杂度

```java
// 复杂度 O(N*W)
for (int i = 1; i <= N; i++) {
    for (int w = 1; w <= W; w++) {
        dp[i][w] = ...;
    }
}

// 1 + 2 + ... + n = n/2 + (n^2)/2
// 用 Big O 表示化简为 O(n^2)
for (int i = 0; i < n; i++) {
    for (int j = i; j >= 0; j--) {
        dp[i][j] = ...;
    }
}
```

## 有时候只看嵌套循环的层数并不准确，还得看算法具体在做什么

- 一文秒杀所有 nSum 问题, 这段算法的逻辑就是 lo 和 hi 不断相向而行，相遇时算法结束，那么它的时间复杂度就是线性的 O(N)。

- 滑动窗口算法, 用 N 代表字符串 s 的长度，那么该算法做的事情就是把 left 和 right 两个指针从 0 移动到 N，所以滑动窗口算法的时间复杂度为线性的 O(N)
