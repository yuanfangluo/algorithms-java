# 并查集（Union-Find）算法

- 并查集（Union-Find）算法是一个专门针对「动态连通性」的算法
- 而且它也是最小生成树算法的前置知识

## 动态连通性

```java
class UF {
    // 将 p 和 q 连接
    public void union(int p, int q);
    // 判断 p 和 q 是否连通
    public boolean connected(int p, int q);
    // 返回图中有多少个连通分量
    public int count();
}
```

## 基本思路

- 注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。
- 因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。
- 怎么用森林来表示连通性呢？
- 我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。
- 如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：
- 这样，如果节点 p 和 q 连通的话，它们一定拥有相同的根节点：

- 那么这个算法的复杂度是多少呢？我们发现，主要 API connected 和 union 中的复杂度都是 find 函数造成的，所以说它们的复杂度和 find 一样。
- find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。
- 我们可能习惯性地认为树的高度就是 logN，但这并不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 N。
- 所以说上面这种解法，find , union , connected 的时间复杂度都是 O(N)。
- 这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 union 和 connected 的调用非常频繁，每次调用需要线性时间完全不可忍受。
- 问题的关键在于，如何想办法避免树的不平衡呢？只需要略施小计即可。

## 平衡性优化

- 我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。
- 解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，我们不妨称为「重量」
- 这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 logN 这个数量级，极大提升执行效率。
- 此时，find , union , connected 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。

## 路径压缩

- 其实我们并不在乎每棵树的结构长什么样，只在乎根节点。
- 因为无论树长啥样，树上的每个节点的根节点都是相同的，所以能不能进一步压缩每棵树的高度，使树高始终保持为常数？
- 这样每个节点的父节点就是整棵树的根节点，find 就能以 O(1) 的时间找到某一节点的根节点，相应的，connected 和 union 复杂度都下降为 O(1)。
- 第一种是在 find 中加一行代码：

```java
private int find(int x) {
        while (parent[x] != x) {
            // 这行代码进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
```

- 路径压缩的第二种写法是这样：

```java
 // 第二种路径压缩的 find 方法
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
```

- 比起第一种路径压缩，显然这种方法压缩得更彻底，直接把一整条树枝压平，一点意外都没有。
- 就算一些极端情况下产生了一棵比较高的树，只要一次路径压缩就能大幅降低树高，从 摊还分析 的角度来看，所有操作的平均时间复杂度依然是 O(1)，
- 所以从效率的角度来说，推荐你使用这种路径压缩算法。
- 另外，如果使用路径压缩技巧，那么 size 数组的平衡优化就不是特别必要了

- Union-Find 算法的复杂度可以这样分析：
- 构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；
- 连通两个节点 union、判断两个节点的连通性 connected、计算连通分量 count 所需的时间复杂度均为 O(1)。
